(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{534:function(t,a,v){t.exports=v.p+"assets/img/JVM-001.3af9ef10.png"},535:function(t,a,v){t.exports=v.p+"assets/img/JVM-002.30cbfffd.png"},552:function(t,a,v){"use strict";v.r(a);var s=v(6),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"一、jvm"}},[t._v("一、JVM")]),t._v(" "),s("p",[t._v("java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。比如kotlin、scala等。\njvm有很多，不只是Hotspot，还有JRockit、J9等等。")]),t._v(" "),s("h2",{attrs:{id:"二、-jvm的基本结构"}},[t._v("二、 JVM的基本结构")]),t._v(" "),s("h3",{attrs:{id:"_1-jvm由三个主要的子系统构成"}},[t._v("1. JVM由三个主要的子系统构成")]),t._v(" "),s("ul",[s("li",[t._v("类加载子系统")]),t._v(" "),s("li",[t._v("运行时数据区（内存结构）")]),t._v(" "),s("li",[t._v("执行引擎\n"),s("diV",{attrs:{align:"center"}},[s("img",{staticStyle:{zoom:"100%"},attrs:{src:v(534)}})])],1)]),t._v(" "),s("h3",{attrs:{id:"_2-运行时数据区-内存结构"}},[t._v("2. 运行时数据区（内存结构）")]),t._v(" "),s("h4",{attrs:{id:"_2-1-方法区-method-area"}},[t._v("2.1 方法区（Method Area）")]),t._v(" "),s("p",[t._v("类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是为了和Java的堆区分开。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-堆-heap"}},[t._v("2.2 堆（Heap）")]),t._v(" "),s("p",[t._v("虚拟机启动时自动分配创建，用于存放对象的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。\n"),s("diV",{attrs:{align:"center"}},[s("img",{staticStyle:{zoom:"100%"},attrs:{src:v(535)}})])],1),t._v(" "),s("h5",{attrs:{id:"_2-2-1-新生代-young-generation"}},[t._v("2.2.1 新生代（Young Generation）")]),t._v(" "),s("p",[t._v("类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。\n新生代分为两部分：伊甸区（Eden space）和幸存者区（Survivor space），所有的类都是在伊甸区被new出来的。幸存区又分为From和To区。当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收（Minor GC），将Eden区中的不再被其它对象应用的对象进行销毁。然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区。")]),t._v(" "),s("h5",{attrs:{id:"_2-2-2-老年代-old-generation"}},[t._v("2.2.2 老年代（Old Generation）")]),t._v(" "),s("p",[t._v("新生代经过多次GC仍然存货的对象移动到老年区。若老年代也满了，这时候将发生Major GC（也可以叫Full GC），进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM（OutOfMemoryError）异常。")]),t._v(" "),s("h5",{attrs:{id:"_2-2-3-元空间-meta-space"}},[t._v("2.2.3 元空间（Meta Space）")]),t._v(" "),s("p",[t._v("在JDK1.8之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。")]),t._v(" "),s("h4",{attrs:{id:"_2-3-栈-stack"}},[t._v("2.3 栈(Stack)")]),t._v(" "),s("p",[t._v("Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致。")]),t._v(" "),s("h4",{attrs:{id:"_2-4-本地方法栈-native-method-stack"}},[t._v("2.4 本地方法栈(Native Method Stack)")]),t._v(" "),s("p",[t._v("和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记native方法，在Execution Engine执行时加载本地方法库。")]),t._v(" "),s("h4",{attrs:{id:"_2-5-程序计数器-program-counter-register"}},[t._v("2.5 程序计数器(Program Counter Register)")]),t._v(" "),s("p",[t._v("就是一个指针，指向方法区中的方法字节码（用来存储指向吓一跳指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。")]),t._v(" "),s("h2",{attrs:{id:"三、jdk性能调优监控工具"}},[t._v("三、JDK性能调优监控工具")]),t._v(" "),s("h3",{attrs:{id:"_1-jinfo"}},[t._v("1. Jinfo")]),t._v(" "),s("h4",{attrs:{id:"_1-1-查看jvm的参数"}},[t._v("1.1 查看JVM的参数")]),t._v(" "),s("p",[t._v("查看正在运行的Java程序的进程ID")]),t._v(" "),s("div",{staticClass:"language-cmd line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("jps\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("查看正在运行的Java程序的扩展参数（后面加进程ID）")]),t._v(" "),s("div",{staticClass:"language-cmd line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("jinfo -flags 1769\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h4",{attrs:{id:"_1-2-查看java系统属性"}},[t._v("1.2 查看java系统属性")]),t._v(" "),s("p",[t._v("查看java系统属性（后面加进程ID）")]),t._v(" "),s("div",{staticClass:"language-cmd line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("jinfo -sysprops 1768\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"_2-jstat"}},[t._v("2. Jstat")]),t._v(" "),s("h3",{attrs:{id:"_3-jmap"}},[t._v("3. Jmap")]),t._v(" "),s("h4",{attrs:{id:"_3-1-堆的对象统计"}},[t._v("3.1 堆的对象统计")]),t._v(" "),s("h4",{attrs:{id:"_3-2-堆信息"}},[t._v("3.2 堆信息")]),t._v(" "),s("h4",{attrs:{id:"_3-3-堆内存dump"}},[t._v("3.3 堆内存dump")]),t._v(" "),s("h3",{attrs:{id:"_4-jstack"}},[t._v("4.  Jstack")]),t._v(" "),s("h2",{attrs:{id:"四、类加载机制"}},[t._v("四、类加载机制")]),t._v(" "),s("h2",{attrs:{id:"五、gc算法和收集器"}},[t._v("五、GC算法和收集器")]),t._v(" "),s("h2",{attrs:{id:"六、调优"}},[t._v("六、调优")])])}),[],!1,null,null,null);a.default=e.exports}}]);